using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace InfusionAPI
{
    public class ExploitApi
    {
        private static string MainVersion = new WebClient().DownloadString("https://raw.githubusercontent.com/skiiiiiiiiiiiiiiiiiiiiiiiiiii/InfusionAPI/main/Version.cc");
        private static string CurrentVersion = "1.0.0";
        private static InjectionStatus Status;
        public static InjectionStatus CurrentStatus;
        private static BaseFunctions.ProcInfo PlayerInfo;
        private static Process Player;
        private static bool CurrentlyInjecting;
        public static bool CheckApiVersion;

        public static bool IsInjected()
        {
            if (ExploitApi.Player == null || ExploitApi.PlayerInfo == null || ExploitApi.PlayerInfo.processRef == null)
                return false;
            try
            {
                return !ExploitApi.Player.HasExited && !ExploitApi.PlayerInfo.processRef.HasExited;
            }
            catch (InvalidOperationException ex)
            {
                return false;
            }
        }

        private static InjectionStatus InjectB(
          BaseFunctions.ProcInfo pinfo,
          string directory,
          bool showconsole,
          bool admin)
        {
            if (ExploitApi.CurrentlyInjecting)
            {
                ExploitApi.CurrentStatus = InjectionStatus.ALREADY_INJECTING;
                return InjectionStatus.ALREADY_INJECTING;
            }
            if (ExploitApi.IsInjected())
            {
                ExploitApi.CurrentStatus = InjectionStatus.ALREADY_INJECTED;
                return InjectionStatus.ALREADY_INJECTED;
            }
            ExploitApi.CurrentlyInjecting = true;
            BaseFunctions.FindWindow((string)null, "Roblox");
            ExploitApi.Player = BaseFunctions.ConsoleHelper.ExecuteAsAdmin(directory, showconsole, admin);
            ExploitApi.PlayerInfo = pinfo;
            ExploitApi.CurrentlyInjecting = false;
            ExploitApi.CurrentStatus = InjectionStatus.SUCCESS;
            return InjectionStatus.SUCCESS;
        }

        public static void wtfdebug()
        {
        }

        public static void Execute(string source)
        {
            System.IO.File.WriteAllBytes(Path.GetTempPath() + "celery" + "\\myfile.txt", Encoding.UTF8.GetBytes(source));
        }

        public static InjectionStatus Inject(string directory, bool showconsole, bool runasadmin)
        {
            if (ExploitApi.CheckApiVersion && ExploitApi.CurrentVersion != ExploitApi.MainVersion)
            {
                int num = (int)MessageBox.Show("Please update ccapi.\nCopied Discord link to clipboard.", "ccapi");
                Clipboard.SetText("https://discord.gg/sW653uZpx9");
                return InjectionStatus.OUTDATED;
            }
            Environment.CreateFiles();
            if (!System.IO.File.Exists(directory))
            {
                int num = (int)MessageBox.Show("The CeleryInject inputted doesnt exist");
                return InjectionStatus.FAILED;
            }
            foreach (BaseFunctions.ProcInfo pinfo in BaseFunctions.openProcessesByName("RobloxPlayerBeta.exe"))
            {
                if (pinfo == null)
                    return InjectionStatus.FAILED;
                if (!ExploitApi.IsInjected())
                {
                    switch (ExploitApi.InjectB(pinfo, directory, showconsole, runasadmin))
                    {
                        case InjectionStatus.FAILED:
                            ExploitApi.CurrentStatus = InjectionStatus.FAILED;
                            return InjectionStatus.FAILED;
                        case InjectionStatus.FAILED_ADMINISTRATOR_ACCESS:
                            ExploitApi.CurrentStatus = InjectionStatus.FAILED_ADMINISTRATOR_ACCESS;
                            return InjectionStatus.FAILED_ADMINISTRATOR_ACCESS;
                        case InjectionStatus.ALREADY_INJECTING:
                            ExploitApi.CurrentStatus = InjectionStatus.ALREADY_INJECTING;
                            return InjectionStatus.ALREADY_INJECTING;
                        case InjectionStatus.SUCCESS:
                            ExploitApi.CurrentStatus = InjectionStatus.SUCCESS;
                            Thread.Sleep(500);
                            return InjectionStatus.SUCCESS;
                    }
                }
                else
                {
                    ShowNotification();
                }
            }
            return InjectionStatus.FAILED;
        }
        public static async void ShowNotification()
        {
            await Task.Delay(1750);
            ExploitApi.Execute("\r\ngame:GetService(\"StarterGui\"):SetCore(\"SendNotification\",{[\"Title\"] = \"Success!\",[\"Text\"] = \"CCAPI v2 by wyattongod\",[\"Duration\"] = 20,[\"Button1\"] = \"les goo!\"})");
        }
        public static async void RegisterCustomExecutor(string name, string version)
        {
            await Task.Delay(1000);
            ExploitApi.Execute("getgenv().identifyexecutor = newcclosure(function()\r\n    return \"" + name + " (CCAPI)\", \"" + version + "\";\r\nend)");
        }

        public static void QuitRoblox()
        {
            if (!ExploitApi.IsClient())
                return;
            ExploitApi.GetClient().Kill();
        }

        public static bool IsClient() => Process.GetProcessesByName("RobloxPlayerBeta").Length != 0;

        public static Process GetClient()
        {
            return ExploitApi.IsClient() ? Process.GetProcessesByName("RobloxPlayerBeta")[0] : (Process)null;
        }

        public static List<BaseFunctions.ProcInfo> GetInjectedProcesses()
        {
            List<BaseFunctions.ProcInfo> injectedProcesses = new List<BaseFunctions.ProcInfo>();
            if (ExploitApi.IsInjected())
                injectedProcesses.Add(ExploitApi.PlayerInfo);
            return injectedProcesses;
        }
    }
}
